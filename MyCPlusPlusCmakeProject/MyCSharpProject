public MyClass{
    public MyClass(){

    }

    public void InvokeMethodFromAnotherClass<T>()
        where T : class
    {
        //construct class name dynamically
        string className = $"{typeof(T).FullName}name";

        //find the .dll from assembly
        Assembly assembly = typeof(T).Assembly;

        //get Type object for the generated class
        Type newClassNmae = assembly.GetType(className);
        if(newClassNmae == null){
            //class not found
            return;
        }

        //get the static method name
        MethodInfo getTypeMethodName = newClassNmae.GetMethod("MethodNameHere", BindingFlags.Static | BindingFlags.Public);
        if(getTypeMethodName == null){
            //method name not found
            return;
        }

        //for methods with returning values
        string methodValue = (string)getTypeMethodName.Invoke(null, null);
        bool methodValue = (bool)getTypeMethodName.Invoke(null, null);
        int methodValue = (int)getTypeMethodName.Invoke(null, null);

        //for methods with parameters
        getTypeMethodName.Invoke(null, new object[] {Parameter, Parameter}); 
    }

    public bool ExecuteScript(string script, string args = null)
    {
        string baseDirectory = "{full path}";
        string fullScriptPath = Path.Combine(baseDirectory, script);

        // check if the script exist
        if(!File.Exists(fullScriptPath))
        {
            Console.WriteLine($"{script} at {fullScriptPath} does not exist");
            return;
        }

        ProcessStartInfo processInfo = new ProcessStartInfo
        {
            FileName = fullScriptPath;
            Arguments = args;
            useShellExecute = false;
            RedirectStandardOutput = true;
            RedirectStandardError = true;
            CreateNoWindow = true;
        }

        try
        {
            using (Process process = Process.Start(processInfo))
            {
                if (process == null)
                {
                    Console.WriteLine("Error: Process is null");
                    return;
                }

                // Read the output and errors
                string output = process.StandardOutput.ReadToEnd();
                string error = process.StandardError.ReadToEnd();

                process.WaitForExit();

                Console.WriteLine("Output: " + output);
                if (!string.IsNullOrEmpty(error))
                {
                    Console.WriteLine("Error: " + error);
                }
                else
                {
                    Console.WriteLine("Batch file executed successfully.");
                }
            }
        }
        catch(Exception e)
        {
            Console.WriteLine($"Exception: {e.Message}");
        }
    }
}